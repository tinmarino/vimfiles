" VimRc by tinmarino
" vim: sw=2:ts=2:
" TODO: NerdCommenter

" The base
set encoding=utf-8
scriptencoding uft-8
filetype plugin indent on | syntax on
"set pythonthreedll=/usr/lib/python3.8/config-3.8-x86_64-linux-gnu/libpython3.8.so


" Variable (Perso)
  let $PAGER = ''

  " Set v: windows gvim do NOT read .bashrc
  set runtimepath+=$v
  set packpath+=$v

  " Alias
  " One letter
  let $h = expand($HOME)
  let $s = expand('$v/scripts') | let $script = $s
  let $p = expand('$v/pack/bundle/opt') | let $pack = $p | let $opt = $p
  let $d = expand('$v/undo/dump') | let $dump = $d
  " RC
  let $alias = expand('$v/dotfile/bash_aliases.sh')
  let $bashrc = expand('$v/dotfile/bashrc')
  let $gitrc = expand('$v/dotfile/gitconfig')
  let $vimrc = expand('$v/dotfile/vimrc')
  let $tmuxrc = expand('$v/dotfile/tmux.conf')
  let $done = expand('$h/wiki/todo/done.md')
  " Vim
  let $auto = expand('$v/autoload')
  let $ft = expand('$v/ftplugin')
  let $vim = $v


" Variable (Vim)
  let mapleader = ','
  let maplocalleader = ','


" Os specific
  " Termux
  if 'termux' ==? $os
    " Autosave
    if expand('%') !=# ''
      augroup Autosave
        autocmd CursorHold,CursorHoldI *  silent update
      augroup END
    endif
    " Hide file edition message
    set shortmess+=F
  endif


" Plugin
  " Vimwiki
    " Lazycall WikiIndex
    function! Windex(num)
      let l:nr = 1 + vimwiki#vars#get_bufferlocal('wiki_nr')
      if &filetype !=# 'vimwiki' || l:nr != a:num
        execute 'VimwikiIndex ' . a:num
      endif
    endfunction
    function! VimwikiAlias()
      " Load here and in ftpluing
      for command in getcompletion('Vimwiki', 'command')
        let alias = 'W' . command[7:]
        exe ':command! -nargs=* ' . alias . ' ' . command . ' <args>'
      endfor
    endfunction
    " Wiki
    let g:vimwiki_list = []
    let g:vimwiki_list += [{
      \ 'path': '$h/wiki/wiki',
      \ 'path_html': '$h/wiki/wiki_html'
      \ }]
    noremap <leader>ww :VimwikiIndex 1<CR>
    map <leader>w<leader>w :VimwikiMakeDiaryNote 1<CR>
    noremap <leader>wg :call Windex(1)<CR>:VimwikiGoto 
    " Todo
    let g:vimwiki_list += [{
      \ 'path': '$h/wiki/todo',
      \ 'path_html': '$h/wiki/todo_html'
      \ }]
    map <leader>tt :VimwikiIndex 2<CR>
    map <leader>t<leader>t :VimwikiMakeDiaryNote 2<CR>
    noremap <leader>tg :call Windex(2)<CR>:VimwikiGoto 
    noremap <leader>ta :call Windex(2)<CR>:VimwikiGoto Alma<CR>
    " Alma
    let g:vimwiki_list += [{
      \ 'path': '$h/wiki/alki',
      \ 'path_html': '$h/wiki/alki_html'
      \ }]
    map <leader>aa :VimwikiIndex 3<CR>
    map <leader>a<leader>a :VimwikiMakeDiaryNote 3<CR>
    noremap <leader>ag :call Windex(3)<CR>:VimwikiGoto 
    " Test
    let g:vimwiki_list += [{
      \ 'path': '$h/Test/Wiki',
      \ 'path_html': '$h/Test/Wiki_html',
      \ 'nested_syntaxes': {'python': 'python'}
      \ }]
    " Test wiki syntax
    let g:vimwiki_list += [{
      \ 'path': '$h/Test/WikiDefault',
      \ 'path_html': '$h/Test/WikiDefault_html',
      \ 'syntax': 'default',
      \ 'ext': '.wiki',
      \ }]
    " Filename todo -> setft vimwiki
    augroup Wiki
      au BufNewFile,BufRead */todo      setf vimwiki
    augroup END
    " Map
    " Option
    let g:vimwiki_automatic_nested_syntaxes = 1

    let g:vimwiki_markdown_link_ext = 1
    let g:vimwiki_table_reduce_last_col = 1
    let g:vimwiki_table_mappings = 0
    let g:vimwiki_table_auto_fmt = 1
    let g:vimwiki_hl_headers = 1
    let g:vimwiki_hl_cb_checked = 1
    let g:vimwiki_syntax = 'markdown'
    let g:vimwiki_ext = '.md'
    let g:vimwiki_custom_wiki2html = '$h/wiki/wiki/wiki2html.sh'
    let g:vimwiki_css_name = '/Css/include.css'

    " Test Wiki
    "let g:vimwiki_emoji_enable = 3
    " New
    "let g:vimwiki_cycle_bullets = 1
    "let g:vimwiki_bullet_types = ['-', '‚Ä¢', '‚Üí', '*']
    "let g:vimwiki_nested_syntaxes = {'python': 'python'}
    "let g:vimwiki_ext2syntax = {'.md': 'markdown'}
    ""let g:vimwiki_tag_format = {'pre': '\(^[ -]*tags\s*:.*\)\@<=', 'pre_mark': '', 'post_mark': '', 'sep': '>><<'}
    ""let g:vimwiki_toc_link_format = 1
    let g:vimwiki_global_ext = 1

    "let g:gfm_syntax_emoji_conceal = 1
    "packadd gfm-syntax
    packadd wiki " TODO remove and add autoload
    call VimwikiAlias()

    " Calendar
    let g:calendar_monday = 1

  " TmuxNavigator
    let g:tmux_navigator_no_mappings = 1
    nnoremap <silent> <A-Left>  :TmuxNavigateLeft<cr>
    nnoremap <silent> <Esc>[1;3D :TmuxNavigateLeft<cr>
    nnoremap <silent> <A-Down>  :TmuxNavigateDown<cr>
    nnoremap <silent> <A-Up>    :TmuxNavigateUp<cr>
    nnoremap <silent> <A-Right> :TmuxNavigateRight<cr>
    nnoremap <silent> <Esc>[1;3C :TmuxNavigateRight<cr>
    nnoremap <silent> <A-h>     :TmuxNavigateLeft<cr>
    nnoremap <silent> <A-j>     :TmuxNavigateDown<cr>
    nnoremap <silent> <A-k>     :TmuxNavigateUp<cr>
    nnoremap <silent> <A-l>     :TmuxNavigateRight<cr>
    nnoremap <silent> <Esc>h    :TmuxNavigateLeft<cr>
    nnoremap <silent> <Esc>j    :TmuxNavigateDown<cr>
    nnoremap <silent> <Esc>k    :TmuxNavigateUp<cr>
    nnoremap <silent> <Esc>l    :TmuxNavigateRight<cr>
    " See: For alt keys https://stackoverflow.com/questions/6778961/alt-key-shortcuts-not-working-on-gnome-terminal-with-vim
    exe "set <A-h>=\eh"
    exe "set <A-j>=\ej"
    exe "set <A-k>=\ek"
    exe "set <A-l>=\el"
    exe "set <A-e>=\ee"
    set ttimeout ttimeoutlen=10

  " YouCompleteMe
    let g:ycm_always_populate_location_list = 1 " use :lne and :lp to navigate
    let g:ycm_python_binary_path = 'python3'
    let g:ycm_autoclose_preview_window_after_completion = 1
    let g:ycm_min_num_of_chars_for_completion = 1

  " Pymode (package python-mode)
    let g:pymode_python = 'python3'
    " They `set nowrap` !!
    let g:pymode_options = 0
    let pymode_lint_checkers = ['pylint', 'pep8']
    " Use rope
    let g:pymode_rope = 1
    let g:pymode_rope_completion = 1
    let g:pymode_rope_complete_on_dot = 0
    let g:pymode_rope_completion_bind = '<C-Space>'
    let g:pymode_rope_autoimport = 0
    let g:pymode_rope_autoimport_modules = ['os', 'shutil', 'datetime', 'numpy']
    let g:pymode_rope_goto_definition_bind = '<C-]>'
    let g:pymode_rope_goto_definition_cmd = 'e'
    " Auto open cwindow (quickfix) if any errors have been found
    let g:pymode_lint_cwindow = 0
    " Pylint ignore
      let s = []
      " Important
      call add(s, 'E303')  " Too many blank lines
      call add(s, 'E501')  " Line too long > 80
      call add(s, 'E701')  " Multiple statement on one line
      call add(s, 'E702')  " Multiple statement on one line (colon)

      " For vimspector
      call add(s, 'E111')  " Indentation not a multiple of 4
      call add(s, 'E114')  " Indentation not a multiple of 4 (comment)
      call add(s, 'E201')  " Whitespace after '('
      call add(s, 'E202')  " Whitespace before ')'
      call add(s, 'E251')  " unespected space around keyword / operator =
      call add(s, 'E131')  " continuation line unaligned for hanging indent
      call add(s, 'E129')  " visually indented line with same indent as next logical line
      " For dirty cats (jupyter-vim)
      " call add(s, 'E302')  " Expected 2 blank lines, found 1
      " call add(s, 'E265')  " Block comment should start with '# '
      " call add(s, 'E305')  " Expected 2 blank lines after class or function definition, found 1

      let pymode_lint_ignore = s
    " Do not perform mapping in ipython (it removes my previous <c-s>
    let g:ipy_perform_mappings = 0
    " Do not highlight spaces
    let g:pymode_syntax_space_errors = 0
    " Do not overwrite my ,b map
    let g:pymode_breakpoint = 0
    " Stop harassing me
    let g:pymode_options_max_line_length = 120
    " Fast fix
    sign define Pymode' text=1

  " ConqueDbg, a gdb plugging
    let g:ConqueGdb_Disable = 1
    let g:ConqueTerm_Color = 2         " 1: strip color after 200 lines, 2: always with color
    let g:ConqueTerm_CloseOnEnd = 1    " close conque when program ends running
    let g:ConqueTerm_StartMessages = 0 " display warning messages if conqueTerm is configured incorrectly
    let g:ConqueTerm_PyVersion = 3

  " Vdebug
    let g:vdebug_keymap = {
    \    'run' : '<F5>',
    \    'close' : '<F6>',
    \    'detach' : '<F7>',
    \    'run_to_cursor' : '<F8>',
    \    'set_breakpoint' : '<F9>',
    \    'step_over' : '<F10>',
    \    'step_into' : '<F11>',
    \    'step_out' : '<F12>',
    \    'get_context' : '<F2>',
    \    'eval_under_cursor' : '<F3>',
    \    'eval_visual' : '<Leader>e',
    \}

  " Vim Translator
    ".vimrc
    " language code iso 639-1
    "? define key in visual-mode (optional)
    let g:goog_user_conf = { 'langpair': 'en|ru', 'cmd': 'node', 'v_key': 'T' }

  " AnsiEsc
    " au BufWinEnter *.a.txt AnsiEsc
    " au BufWinEnter *.a.txt set nowrap | echom "I saw an ansi file"
    " au ColorScheme * AnsiEsc!

  " Emacs Command line
    let g:EmacsCommandLineSearchCommandLineDisable = 1
    let g:EmacsCommandLineBackwardCharDisable = 1

  " Eclim
    let g:EclimCompletionMethod = 'omnifunc'

  " Vimtex
    let g:tex_stylish = 1
    let g:tex_flavor = 'latex'
    " No autoindent
    let g:vimtex_indent_enabled = 0
    " Disable overfull/underfull \hbox
    let g:vimtex_quickfix_latexlog = {
        \ 'overfull' : 0,
        \ 'underfull' : 0,
        \}

  " Ultisnip
    let g:UltiSnipsSnippetDirectories = [$v . '/template/my_snippets', $v . '/pack/bundle/opt/snippets/UltiSnips']
    " Disable search in rtp because I already gave you the path
    let g:UltiSnipsEnableSnipMate = 0

    let g:UltiSnipsExpandTrigger='<c-j>'
    let g:UltiSnipsUsePythonVersion = 3

  " Viewdoc
    let g:no_viewdoc_abbrev = 1
    let g:viewdoc_open = 'e'

  " Table mode
    let g:table_mode_tableize_map = ',i'

  " Ack to use ag
    let g:ack_qhandler='rightbelow vert copen 80'
    let g:ackprg = 'ag --vimgrep --smart-case'
    "cnoreabbrev ag Ack
    "cnoreabbrev aG Ack
    "cnoreabbrev Ag Ack
    "cnoreabbrev AG Ack

  " Vimspector
    let g:vimspector_enable_mappings = 'HUMAN'

  " Fzf
    " https://github.com/junegunn/fzf/issues/274
    let g:fzf_layout = { 'down': '100%' }

    function! FzfRg(query, fullscreen, files)
      let command_fmt = 'rg --column --line-number --no-heading --color=always --smart-case -- %s ' . a:files . ' || true'
      let initial_command = printf(command_fmt, shellescape(a:query))
      let reload_command = printf(command_fmt, '{q}')
      let spec = {'options': ['--phony', '--query', a:query, '--bind', 'change:reload:'.reload_command]}
      call fzf#vim#grep(initial_command, 1, fzf#vim#with_preview(spec), a:fullscreen)
    endfunction
    command! -nargs=* -bang RG call FzfRg(<q-args>, <bang>0, '')
    command! -nargs=* -bang FzfOldLines call FzfRg(
                \ <q-args>, <bang>0, join(fzf#vim#_recent_files(), ' '))

    function! FzfRgFileFull()
      " Start source list command
      let _fzf_source = 'bash -c "'
      " -- Buffer list
      let _fzf_source .= 'echo -e \"' . join(map(getbufinfo(), 'v:val.name'), '\n') . '\";'
      " -- Oldfiles
      let _fzf_source .= 'echo -e \"'.join(fzf#vim#_recent_files(), '\n').'\";'
      " -- Current dir
      let _fzf_source .= 'rg --color never --files \".\";'
      " -- Vim dir
      let _fzf_source .= 'rg --color never --files \"$v\";'
      " -- HOME dir
      let _fzf_source .= 'rg --color never --files \"$HOME\";'
      " End
      let _fzf_source .= '"'
      call fzf#run(fzf#wrap({
                \'source': _fzf_source,
                \'sink' : 'e ',
                \'options' : $FZF_DEFAULT_OPTS
                \}))
    endfunction
    command! FzfRgFileFull call FzfRgFileFull()

  " Ale
    let g:ale_python_autopep8_options = '--indent-size=4  --max-line-length=120 '


" PackAdd
  " Interface: 5ms for 4plugings
  packadd fzf
  packadd fzf.vim
  packadd lastplace  " vi $VIMRUNTIME/vimrc_example.vim
  packadd submode  " Map C-W

  function TinPack(timer)
    " Lazy loader
    " Interface:
    packadd fugitive
    " Map: 10ms for 9pg
    packadd surround  " ySS<div>
    packadd repeat  " for surround
    packadd textobj-user  " for function
    packadd textobj-arg  " daa
    packadd textobj-indent  " dai
    packadd textobj-function  " daf
    packadd unimpaired  " 5ms  ]b (:bn) , ]<space> (add empty lines), ]q
    packadd tmux-navigator  " ]q
    packadd emacscommandline  " 3ms
    " Misc:
    packadd vader
    " ALE:
    " Removes flakes8
    let g:ale_linters = {
          \ 'python': ['mypy', 'pylint', 'pyright']}
    let g:ale_pattern_options = {
          \ '.*\.md$': {'ale_enabled': 0}}
    packadd ale
    " Youcompleteme: is verbose at init if no python
    try
      python3 '42'
      packadd youcompleteme
      call youcompleteme#Enable()
    catch | endtry
    " Ultisnip: is annoying at run time if no python
    try
      python3 '42'
      packadd ultisnips  " 3ms
      packadd snippets " for some ultisnips macro
    catch | endtry
  endfunction

  " Call it
  if has('timers')
    call timer_start(200, 'TinPack')
  else
    call TinPack(42)
  endif


" Appearance
  " Preferences
    set background=dark
    packadd color-tin
    colorscheme gruvbox-material
    set t_Co=256  " For airline and nice colors
    set formatoptions-=cro  " No auto comment
    "augroup NoCommment
    "  autocmd FileType *.py setlocal formatoptions-=c formatoptions-=r formatoptions-=o
    "augroup END
    set diffopt+=vertical
    set title                    " change the terminal's title, may not work
    set autoindent  " to have auto indentation when return line
    set wrapscan
    set conceallevel=2
    set number
    set modeline
    " Terminal italic
    set t_ZH=[3m
    set t_ZR=[23m
    " Terminal strikethrough
    if $os ==# 'windows'
      set term=xterm
    else
      set term=xterm-256color
    endif
    " Mouse Integration
    set mouse=a " Enable mouse use in all modes
    set ttyfast
    set ttymouse=xterm2
  " Statusline
    function! Rc_add_path() abort
      let dir = expand('%:h')
      if dir ==# '' || dir ==# '.' | return '' | endif
      return '    ' . dir . '/'
    endfunction
    set laststatus=2        " alwaus show statusline
    set statusline=         " init void
    set statusline+=%m      " gflag modified
    set statusline+=%t      " tail of the filename
    set statusline+=%{Rc_add_path()} " head of path
    set statusline+=%=      " left/right separator
    set statusline+=%P\ \   " percent through file
    set statusline+=%c,     " cursor column
    set statusline+=%l/%L   " cursor line/total lines
  " File format
    set fileformat=unix
    set wrap
    set expandtab
    set shiftwidth=2
    set tabstop=2
  " Gui
    set guifont=Consolas:h14:cANSI:qDRAFT
    set guioptions-=T                  " Toolbar
    set guioptions-=m                  " Menumbar
  " Wildignore : Ignore these filenames during enhanced command line completion.
    set wildmenu
    set wildmode=list:full
    set wildignore+=*.aux,*.out,*.toc,*.fdb_latexmk,*.pdf,*.fls,*.synctex.gz,*.dvi,*.svg,*.log  " LaTeX intermediate files
    set wildignore+=*.tex.backup,*.lg,*.4ct,*.4tc,*.tmp,*.idv  " LaTeX html intermediate files
    set wildignore+=*.jpg,*.bmp,*.gif,*.png  " binary images
    set wildignore+=*.luac  " Lua byte code
    set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest  " compiled object files
    set wildignore+=*.pyc  " Python byte code
    set wildignore+=*.spl  " compiled spelling word lists
    set wildignore+=*.sw?  " Vim swap files
    set wildignore+=.git/*,undo/*  " Git, Vim undo
  " Search
    set ignorecase
    set smartcase
    set hlsearch      " highlight search terms
    set incsearch     " show search matches as you type
  " Cursor
    set cursorline  " Enable CursorLine
    " Default Colors for CursorLine
    highlight  CursorLine term=underline cterm=underline ctermbg=None ctermfg=None
    augroup Cursor
      "Change Color when entering Insert Mode
      autocmd InsertEnter * highlight  CursorLine term=None cterm=None
      " Revert Color to default when leaving Insert Mode
      autocmd InsertLeave * highlight  CursorLine term=underline cterm=underline ctermbg=None ctermfg=None
    augroup END
  " Window
    set ruler
    set backspace=2
    " set shell=H:/Program/cmder-1.2.9/Cmder.exe
  " Viminfo rememebr last 10000 opened files
  let s:viminfo=join(map(split(&viminfo, ','), {arg -> (v:val[0] == "'" ? "'10000" : v:val)}), ',')
  exe('set viminfo=' . s:viminfo)

  " Tabline
    " Rename tabs to show tab number.
    " Based on: http://stackoverflow.com/questions/5927952/whats-implementation-of-vims-default-tabline-function
    " Copied from: https://superuser.com/questions/331272/vim-show-the-index-of-tabs-in-the-tabline
    if exists('+showtabline')
      function! MyTabLine()
        let s = ''
        let wn = ''
        let t = tabpagenr()
        let i = 1
        while i <= tabpagenr('$')
          let buflist = tabpagebuflist(i)
          let winnr = tabpagewinnr(i)
          let s .= '%' . i . 'T'
          let s .= (i == t ? '%1*' : '%2*')
          let s .= ' '
          let wn = tabpagewinnr(i,'$')

          let s .= '%#TabNum#'
          let s .= i
          " let s .= '%*'
          let s .= (i == t ? '%#TabLineSel#' : '%#TabLine#')
          let bufnr = buflist[winnr - 1]
          let file = bufname(bufnr)
          let buftype = getbufvar(bufnr, 'buftype')
          if buftype ==# 'nofile'
            if file =~# '\/.'
              let file = substitute(file, '.*\/\ze.', '', '')
            endif
          else
            let file = fnamemodify(file, ':p:t')
          endif
          if file ==# ''
            let file = '[No Name]'
          endif
          let s .= ' ' . file . ' '
          let i = i + 1
        endwhile
        let s .= '%T%#TabLineFill#%='
        let s .= (tabpagenr('$') > 1 ? '%999XX' : 'X')
        return s
      endfunction
      set showtabline=2
      set tabline=%!MyTabLine()
      set showtabline=1
      highlight link TabNum Special
    endif


" Backup
  set nobackup
  set noswapfile
  set nowritebackup
  set undolevels=10000
  set history=10000

  if has('persistent_undo')
    set undodir=$v/undo
    set undofile
  endif


" Map Leadered
  " Edit special files
    function! Edit(file)
      try | execute 'buffer ' . a:file
      catch | execute 'edit ' . a:file
      endtry
    endfunction
    nnoremap <Leader>ea :call Edit($alias)<CR>
    nnoremap <Leader>eb :call Edit($bashrc)<CR>
    nnoremap <Leader>ec :call Edit($h .'/.alacritty.yml')<CR>
    nnoremap <Leader>ed :call Edit($h . '/wiki/todo/done.md')<CR>
    nnoremap <Leader>ef :e $v/ftplugin/<C-D>
    nnoremap <Leader>eg :call Edit($gitrc)<CR>
    nnoremap <Leader>et :call Edit($tmuxrc)<CR>
    nnoremap <Leader>ev :call Edit($vimrc)<CR>
  " a, t, w for wiki
  " b -> Backup file
    function! Backup(s)
      " Backup path
      let bck_file = expand('$v/undo/bck_') . strftime('%y-%m-%d-%H-%M-%S')
      " File path
      let bck_file .= '--' . substitute(expand('%:p:r'), '/', '_', 'g')
      " Extension
      let bck_file .= '-' . a:s . '.' . expand('%:e')
      silent execute a:s . 'write! ' . bck_file
      echom 'Backup lines ' . a:s . ' of file: $bck_file = ' . bck_file
    endfunction
    command! -range=% Backup call Backup('<line1>,<line2>')
    " :BackView to feed backup path of the day in command line
    command! -range=% BackupView call feedkeys(':e '
                \ . expand('$v/undo/bck_') . strftime('%y-%m-%d'))
    nnoremap <leader>b :Backup<CR>
    vnoremap <leader>b :Backup<CR>
  " f -> fuzzy -> Fzf
    " Some have shortcut ,f -> C-
    nnoremap <Leader>fb :BLines<Cr>
    nnoremap <Leader>fe :FzfRgFileFull<Cr>
    nnoremap <Leader>ff :FzfOldLines " Same C-n<Cr>
    nnoremap <Leader>fn :FzfOldLines<Cr>
    nnoremap <Leader>fg :Commits<Cr>
    nnoremap <Leader>fv :call fzf#run({'options': '--reverse --prompt "VimFiles"', 'down': 20, 'dir': '~/.vim/', 'sink': 'e' })<Cr>
    nnoremap <Leader>fw :call FzfRg('', 1, $w)<Cr>
  " g -> git -> Fugitive
    map <leader>gd :Gdiff<CR>
    map <leader>gb :Gblame<CR>
    map <leader>gs :Gstatus<CR>
    map <leader>gl :Glog<CR>
    map <leader>gc :Gcommit -m ""<C-b>
    map <leader>ga :Git add
  " k -> :Calendar
    nnoremap <leader>k :packadd calendar <bar> Calendar<CR>
  " n -> :NERDTree
    function! NERDTreeExists()
      let cr_tab = tabpagenr()
      for i in range(1, tabpagenr('$'))
        if i == cr_tab | continue | endif
        if len(gettabvar(i, 'NERDTreeBufName')) | return 1 | endif
      endfor
      return 0
    endfunction

    function! NERDTreeToogleMirror()
      packadd nerdtree
      if g:NERDTree.IsOpen() || exists('t:NERDTreeBufName') || !NERDTreeExists()
        NERDTreeToggle
      else
        NERDTreeMirror
      endif
    endfunction
    noremap <leader>n :call NERDTreeToogleMirror()<CR>
  " r -> Ag the silver searcher <- ack r like RipGrep
    noremap <expr> <leader>r ":update<Cr>:silent packadd ack<CR>:Ack! '"
          \ . expand('<cword>') . "'"
    noremap <leader>ak :silent packadd ack<CR>:Ack! ''<LEFT>
  " u -> :UndotreeToggle
    noremap <leader>u :silent packadd undotree<CR>:UndotreeToggle<CR>


" Map Ctrl, Alt
  nnoremap <C-b> :BLines<Cr>
  if 'termux' ==? $os
    nnoremap <Leader>e :FzfRgFileFull<Cr>
  else
    nnoremap <C-e> :FzfRgFileFull<Cr>
    nnoremap <A-e> :FzfRgFileFull<Cr>
    exe "set <A-e>=\ee"
  endif
  nnoremap <C-n> :FzfOldLines<Cr>


" Map
  tnoremap <Esc> <C-W>N

  " NetRw Open Link
    function! OpenLink(...)
      let link = a:0 ? a:1 : expand('<cWORD>')
      if link =~? '^ICT-\d*'
        let link = 'https://ictjira.alma.cl/browse/' . link
      endif
      exe '!xdg-open ' . link . '&'
    endfunction
    nmap gx yiW:call OpenLink() <Cr><Cr>
  " Save with s
    noremap s      :update!<CR>
    vnoremap s    <C-C>:update!<CR>

  " Use <C-L> to clear the highlighting of :set hlsearch and also preserve the
  " default behavior of redrawing the screen
    if maparg('<C-S-L>', 'n') ==# ''
        nnoremap <silent> <C-S-L> :nohlsearch<C-R>=has('diff')?'<Bar>diffupdate':''<CR><CR><C-L>
    endif

  " Window
    noremap <C-W>- <C-W>s
    noremap <C-W><bar> <C-W>v
    noremap <C-W>_ <C-W>s
    noremap <C-W>z <C-W><bar>

    " Source: https://ddrscott.github.io/blog/2016/making-a-window-submode/
    function SetWindowMap()
      if !exists('submode#map')
        return
      endif
      " A message will appear in the message line when you're in a submode
      " and stay there until the mode has existed.
      let g:submode_timeoutlen = 4000
      let g:submode_always_show_submode = 1

      " We're taking over the default <C-w> setting. Don't worry we'll do
      " our best to put back the default functionality.
      call submode#enter_with('window', 'n', '', '<C-w>')

      " Note: <C-c> will also get you out to the mode without this mapping.
      " Note: <C-[> also behaves as <ESC>
      call submode#leave_with('window', 'n', '', '<ESC>')

      " Go through every letter
      for key in ['a','b','c','d','e','f','g','h','i','j','k','l','m',
      \           'n','o','p','q','r','s','t','u','v','w','x','y','z']
        " maps lowercase, uppercase and <C-key>
        call submode#map('window', 'n', '', key, '<C-w>' . key)
        call submode#map('window', 'n', '', toupper(key), '<C-w>' . toupper(key))
        call submode#map('window', 'n', '', '<C-' . key . '>', '<C-w>' . '<C-'.key . '>')
      endfor
      " Go through symbols. Sadly, '|', not supported in submode plugin.
      for key in ['=','_','+','-','<','>']
        call submode#map('window', 'n', '', key, '<C-w>' . key)
      endfor

      " I don't like <C-w>q, <C-w>c won't exit Vim when it's the last window.
      call submode#map('window', 'n', '', 'q', '<C-w>c')
      call submode#map('window', 'n', '', '<C-q>', '<C-w>c')

      " <lowercase-pipe> sets the width to 80 columns, pipe (<S-\>) by default
      " maximizes the width.
      call submode#map('window', 'n', '', '\', ':vertical resize 80<CR>')

      " Resize faster
      call submode#map('window', 'n', '', '+', '3<C-w>+')
      call submode#map('window', 'n', '', '-', '3<C-w>-')
      call submode#map('window', 'n', '', '<', '10<C-w><')
      call submode#map('window', 'n', '', '>', '10<C-w>>')
    endfunction

  " Maps for Package : On demand load
    " F8 : Colorscheme-switcher
    noremap <F8> :packadd misc<CR>:packadd colorscheme-switcher<CR><F8>
    map <ESC>[19;2~ <S-F8>

  " Yank all buffer to system clipboard
    map <leader>y mtgg"+yG`t
    map <leader>p ggdG"+p

  " Indent < and >
    noremap > >>
    noremap < <<
    vnoremap > >gv
    vnoremap < <gv

  " select last paste in visual mode
    nnoremap <expr> gb '`[' . strpart(getregtype(), 0, 1) . '`]'

  " Perso maps normal
    nnoremap H :set cursorline! cursorcolumn!<CR>
      map xy :s/x/y/g<CR>
    map yx :s/y/x/g<CR>

  " Copy paste to from clipboard <- ctrl+p
    if $os !=? 'termux'
      " Disabled in termux for wheel
      nnoremap <C-y> "+y
      vnoremap <C-y> "+y
    endif
    nnoremap <C-p> "+p
    vnoremap <C-p> "+p
    " Note: `] goto end of paste
    inoremap <C-p> <Esc>"+p`]a

  " Command : %% to expand path in command mode
    cnoremap %% <C-R>=expand('%:p:h').'/'<CR>|

  " Insert mode begin, end <- c-a c-e shotcuts from gnome
    inoremap <C-A> <C-O>^
    inoremap <C-E> <C-O>g_
    "inoremap <C-K> <C-O>D

  " Esc <- jk or kj
    imap jk <Esc>
    imap kj <Esc>

  " C-Arrow on Ubuntu
    "Get Ctrl + ARROW KEYS,because if you don't do that, the <C-Up>  (ie crtl + up ) key is notreckognise
    map  <Esc>[1;5A <C-Up>
    map  <Esc>[1;5B <C-Down>
    map  <Esc>[1;5D <C-Left>
    map  <Esc>[1;5C <C-Right>
    cmap <Esc>[1;5A <C-Up>
    cmap <Esc>[1;5B <C-Down>
    cmap <Esc>[1;5D <C-Left>
    cmap <Esc>[1;5C <C-Right>

    map  <Esc>[1;2D <S-Left>
    map  <Esc>[1;2C <S-Right>
    cmap <Esc>[1;2D <S-Left>
    cmap <Esc>[1;2C <S-Right>

  " Fold
    nnoremap <space> za
    vnoremap <space> zf
    map z1  :set foldlevel=0<CR><Esc>
    map z2  :set foldlevel=1<CR><Esc>
    map z3  :set foldlevel=2<CR><Esc>
    map z4  :set foldlevel=3<CR><Esc>
    map z5  :set foldlevel=4<CR><Esc>
    map z6  :set foldlevel=5<CR><Esc>
    map z7  :set foldlevel=6<CR><Esc>
    map z8  :set foldlevel=7<CR><Esc>
    map z9  :set foldlevel=8<CR><Esc>
    " And for azery
    map z& z1
    map z√© z2
    map z" z3
    map z' z4
    map z( z5
    map z- z6
    map z√® z7
    map z_ z8
    map z√ß z9

  " Tab
    noremap gn :tabnew<CR>
    noremap g1 :1tabnext<CR><Esc>
    noremap g2 :2tabnext<CR><Esc>
    noremap g3 :3tabnext<CR><Esc>
    noremap g4 :4tabnext<CR><Esc>
    noremap g5 :5tabnext<CR><Esc>
    noremap g6 :6tabnext<CR><Esc>
    noremap g7 :7tabnext<CR><Esc>
    noremap g8 :8tabnext<CR><Esc>
    noremap g9 :9tabnext<CR><Esc>
    " And for azery
    map g& g1
    map g√© g2
    map g" g3
    map g' g4
    map g( g5
    map g- g6
    map g√® g7
    map g_ g8
    map g√ß g9


" Command Man
  if exists(':Man') != 2
    com! -nargs=+ -complete=shellcmd M ru! ftplugin/man.vim | Man <args>
  else
    com! -nargs=+ -complete=shellcmd M Man <args>
  endif


" Folding
  highlight Folded ctermfg=DarkGreen ctermbg=Black
  set foldignore=
  set foldlevelstart=30 "the folding at opening
  set foldmethod=indent
  set foldcolumn=0  "the number of columns on the left to show the tree, default =0
  set foldlevelstart=30 "the folding at opening
  set shiftwidth=4  " the number of column taken into account for aa fold, IMPORTANT


" Filetype
  augroup FtDetect
    au BufNewFile,BufRead *.masm      setf masm
    au BufNewFile,BufRead *.asm       setf masm
    au BufNewFile,BufRead *.disarm    setf disarm
    au BufNewFile,BufRead *.kd        setf kd
  augroup END


" Alma
  " AlmaSw
    "" echo | g++ -E -Wp,-v -
    "" `gcc -print-prog-name=cpp` -v  # cpp for c preprocessor
    "set path+=/usr/lib/gcc/x86_64-linux-gnu/9/include
    "set path+=/usr/local/include
    "set path+=/usr/include/x86_64-linux-gnu
    "set path+=/usr/include
    "" `gcc -print-prog-name=cc1plus` -v
    "set path+=/usr/include/c++/9/
    "set path+=/usr/include/c++/9
    "set path+=/usr/include/x86_64-linux-gnu/c++/9
    "set path+=/usr/include/c++/9/backward
    "set path+=/usr/lib/gcc/x86_64-linux-gnu/9/include
    "set path+=./../include
    "set path+=./../../*/include
    "set path+=./../../../*/include
    "set path+=/home/tourneboeuf/AlmaSw/ACS/LGPL/CommonSoftware/**/include/
    "set path+=/home/tourneboeuf/AlmaSw/ICD/**/include/

    let g:ale_cpp_clang_options=''
    let g:ale_cpp_clang_options.='-I/home/tourneboeuf/AlmaSw/ '
    let g:ale_cpp_clang_options.='-I/home/tourneboeuf/AlmaSw/ACS/LGPL/CommonSoftware/logging/ws/include/ '
    let g:ale_cpp_clang_options.='-I/home/tourneboeuf/AlmaSw/TELCAL/TelCalDataManager/include '


" Fastly (added)
  command! -nargs=0 -bar Helptags for p in glob('~/.vim/pack/bundle/opt/*', 1, 1) | exe 'packadd '.fnamemodify(p, ':t') | endfor | helptags ALL

  " packadd perlomni
  "packadd lexima " autoclose brackets
  "packadd xmledit
  "let xml_use_html = 1

  "imap   <C-k>   <plug>(emmet-expand-abbr)
  " packadd emmet
  " TODO emmet
  "imap   <C-k>   <plug>(emmet-expand-abbr)
  "packadd emmet
  "imap   <C-k>   <plug>(emmet-expand-abbr)
  " let g:jupyter_monitor_console = 1
  "let g:jupyter_verbose = 1
  " let g:jupyter_auto_connect = 1
  " let b:jupyter_exec_before = 'clear-screen'
  packadd jupyter
  packadd spector
  "packadd python-mode
  " if $os == 'unix' packadd youcompleteme endif
  "packadd raku
  " packadd sleuth  " Auto indent
  let g:ycm_confirm_extra_conf = 0
  " autocmd FileType python let b:jupyter_exec_before = 'clear-screen'

  map K :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<' . synIDattr(synID(line("."),col("."),0),"name") . "> lo<" . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<CR>
  " Pb with gruvbox-material
  hi Comment cterm=NONE

  " C-Space omnicompletion
  inoremap <C-Space> <C-x><C-o>
  inoremap <C-@> <C-x><C-o>

function! SynStack()
  if !exists('*synstack')
    return
  endif
  echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')
endfunc
function! SynGroup()
    let l:s = synID(line('.'), col('.'), 1)
    echo synIDattr(l:s, 'name') . ' -> ' . synIDattr(synIDtrans(l:s), 'name')
endfun
