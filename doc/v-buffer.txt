*v#buffer.txt*      Window, Buffer, Tab


1. Split 		    |v#split|
2. Buffer 			|v#buffer|
3. Tab				|v#tab|

===============================================================================
                                                          *v#split* *v#window*
Split, Window ~


Modify Layout ~
<C-W>o          	| Only 
<C-W>q 				| Close current viewport
<C-W>x				| Swap position with next window or [count] next
<C-W>[rR]			| Rotate:(clockwise and counter) change viewport position 
<C-W>[+-]     		| Increase/decrease [count] Current Viewport height
<C-W>[<>]           | Increase/decrease [count] width
<C-W>=				| Igualise viewport size
<C-W>_				| Maximise current window height
<C-W>|				| Maximise current window width
<C-W>[HJKL] 		| Move the current window to the top of the screen, using the full width of the screen.

Move ~
<C-W><C-W> 			| Switch viewport 
<C-W>[hjkl]			| Move to the next viewport
<C-W><arrow>		| Move direction
<C-W>b              | Move to the bottom window
<C-W>t              | Move to the top window
<C-W>p              | MOve to previous window


Create ~
<C-W>s				| Split horizontal
<C-W>v				| Vertical split
<C-W>T				| Window to Tab
CTRL-W CTRL-N
Split the window like :split .The only difference is that if no
filename is specified, a new window is started on a blank file. (Same as: CTRL-Wn ,
:new . See page 48.)

Jumps ~
<C-W>]          | Split the current window and jump to the function whose
name is under the cursor. If a count is specified, it is the height of the new
window.
<C-W>g]         | split followed a CTRL-]
<C-W>^          | Split the window and edit the alternate file. If a count is specified, split the window and edit the count file on the command line.
<C-W>d    
Split the window and find the definition of the word under the
cursor. If the definition cannot be found, do not split the window. <C-W><C-D>
<C-W>f              | Split the window and edit the file whose name is under the cursor.  Looks for the file in the current directory, and then all the directories specified by the ‘path’ option. <C-W><C-F>
<C-W>g}
Do a :ptjump on the word under the cursor. If a count is
specified, make the new window count lines high.
<C-W>i
Split the window and search for the count occurrence of
the word under the cursor. Start the search at the beginning of the file
<C-W>z          | Close preview window
CTRL-W g }
Do a :ptjump on the word under the cursor. (Same as:
See page 277.)



Miscelanous ~
<C-W><C-C>          | Cancel window operation



Options ~
winheight           option When entering or creating a window, set its height to at least the specified value.
winwidth            option When entering or creating a window, set its width to at least the specified value.
equalalways         option When the number of windows changes, either by splitting or closing windows,
eadirection         option Define whether Vim resizes windows equally vertically, horizontally, or both.
cmdheight           option Set the command line height.
winminheight        option Define the minimum window height, which applies to all windows created.
winminwidth         option Define the minimum window width, which applies to all windows created.

Commands ~
:vertical resize n 
:resize 60 or :resize +5
:sp[lit]			| Split Screen horizontaly 
:vsp[lit]			| Split Screen vertically 
:sview 				| Same as :split in readonly mode
:hide 				| Close current window
:on[ly] 			| Close all windows, excepted current

z n <ENTER> Set the current window height to n.
Cw 10+ and Cw 10>
nnoremap <silent> <Leader>+ :exe "resize " . (winheight(0) * 3/2)<CR> nnoremap <silent> <Leader>- :exe "resize " . (winheight(0) * 2/3)<CR>
Some pluginng to use submodes permits Cw ++++
:new
:enew
:below new
set splitright set splitbelow


===============================================================================
                                                *v#buffer*
Buffer ~


:ls			| display buffer list


:bn			| new
:bd			| delete
:b3			| goto 3
:n :p			| next, previous
:rew 			| rewind to 1st file

:args 			| display argument list
:arg 			|Optional: Display the current arglist.
:arg *.cpp 		|All *.cpp files in current directory.
:argadd *.h 		|And all *.h files.
:argdo %s/pattern/replace/ge | update 	Search and replace in all files in arglist. 

:update			| save if changes
:bufdo 			| do the command to all buffer
:e!   			| return to unmodified file
:e #   			| edit alternative file
:e +name		| edit
:w /some/path/%:r 	| save file in another directory, but with the same name
:sav php.html     	| Save current file as php.html and "move" to php.html

:qa          		| quit all 


  bufdo normal 2G"Ayy "which iterates through the buffers and runs the given command in normal mode. 2G jumps to the appropriate line, and "Ay yanks into register a, appending instead of overwriting (since the A is capitalized). Make sure register a is empty before you start

===============================================================================
                                                *v#tab*
Tab ~

:tabnew 		Creates a new tab
:tabp			Go to previous tab 
:tabn			Go to next tab
:gt 			Show next tab
:tabfirst 		Show first tab
:tablast 		Show last tab
:tabm n(position) 	Rearrange tabs
:tabdo %s/foo/bar/g 	Execute a command in all tabs
:tab ball 		Puts all open files in tabs

vim: ft=myhelp
